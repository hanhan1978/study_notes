# WebエンジニアのためのC言語入門ハンズオン #4

# 今日習得すること
+ C言語のデバッグ方法
+ printfマクロを使ったデバッグ演習
+ デバッガの仕組み
+ gdbを使ったデバッグ演習 
+ おまけ lldb

# 概略
C言語におけるデバッグ、及びデバッグに関係する小技を解説します。

作った後、数ヶ月経過したプログラムでは、どこにprintfをおけば、効果的にデバッグできるのかを思い出すだけで大変です。

`printf`デバッグだけでなく、デバッガの使い方を覚えることで、初心者レベルを脱出しましょう。

# 1. C言語のデバッグ方法

## printf
PHPにおける`var_dump`デバッグに近いものです。使い方も簡単で、分かりやすい。 
欠点としては、プロダクションのコードに`printf`を残してはいけないということです。

そのため、デバッグ時に仕込んだ`printf`は、デバッグ完了時に取り除く必要があります。  
もし、同じ箇所でバグが発生した場合は、また入れなおしになってしまいます。

小規模プログラムであれば充分に機能しますが、原始的ですしあまりスマートな感じはしません。

## printfマクロ
マクロを使って、`printf`を置換える方法です。

基本スタイルは`printf`デバッグと同様なのですが、マクロを使うことで、`printf`を撤去する必要がなくなります。

ヘッダーファイルで下記のようなマクロを定義します。
```
#define eprintf(...) fprintf(stderr, __VA_ARGS__) 
```
マクロは、コンパイル前にプリプロセッサによって置換されます。
よって、eprintf関数は、fprintfとして動作します。

デバッグが終わったら、マクロを以下のように書き直します。
```
#define eprintf(...) {} 
```

すると、`eprintf`は何もしないコードに置き換わります。

マクロを使う方法は、ログ出力を行うコードに置換えたり等、汎用性がありそうです。
重要な情報については、とりあえず`eprintf`で出力しておけば、動作チェックするのも楽です。

=> 今日以降、C言語プログラムのデバッグで、printfを使うのは止めにして、macroを利用する方法に切り替えましょう。  

## デバッガ
本日のメインイベントです。
変数の中身を見たり、ステップ実行したり出来ます。

以下は、代表的なC言語のデバッグです。

+ gdb  
GNUシステムの一部として、ストールマンが作成したデバッガ。
=> 組み込み系用にリモートデバッグも可能。
+ ddd  
gdbのGUIインターフェース。機能はGDBと同様だがGUIで操作できる。
+ cgdb  
vimキーバインドで操作できるコマンドラインのgdbインターフェース。
デバッガ作動時にソースコード表示などが出来る。
+ eclipse CDT
IDEのgdbインターフェース。最近はeclipseが下火っぽいので、どれくらいメンテされているのかは分からない。
+ lldb
mac標準のllvm(clang)のデバッガ。llvmでコンパイルした実行可能ファイルは
gccとは≒となっているようで、ある程度複雑なプログラムになってくると互換性がなく、動作しなくなります。
=> 私調べなので、上手くやる方法もあるかもしれません。



# 2. printfマクロを使ったデバッグ

## 演習1 

```
#include <stdio.h>

#define eprintf(...) fprintf(stderr, __VA_ARGS__) 

int main(){

    printf("printf \n");

    eprintf("eprintf \n");
    eprintf("eprintf with args -> [ %s ]\n", "debug message");

}

```

1. まず、`macro.c`という名前で上記コードを保存して下さい。
2. `gcc -o macro macro.c`でコンパイルして、macroコマンドを実行して下さい。
3. 次に`eprintf`を下記の内容に書き換えて下さい。
```
#define eprintf(...) {} 
```
4. 再度、コンパイルして実行して下さい。`eprintf`が何も出力しなくなったらOKです。

# 3. デバッガの仕組み

# 4. gdbを使ったデバッグ演習 
普通にコンパイルしてもデバッグは出来ません。デバッグのための情報を実行可能ファイルに付加する必要があります。

## デバッグのための`gcc`オプション
+ `-g`
helpの内容をそのまま書くと
Generate source-level debug information　です。
つまり、デバッグ情報を実行可能ファイルに付与してくれます。

gccでは、`-g3`とするとgdb内でmacroも使えて便利らしいですが、clang(mac標準)ではg3もgも同じだそうです。

+ `-O0`
Optimizationを0という意味です。
最適化をしないので、デバッグがしやすくなります。

本ハンズオンで扱う程度の簡単プログラムではあまり違いは出ないようです。


## 演習2 gdbのイロハ
下記コードをbasic.cという名前で保存して下さい。  
もはや、コピペでも良いのですが、良い機会なので写経をお勧めします。
※デバッガの演習で行数が大事な要素となります。空白行も含めて、完璧に写経をお願いします。

```
```

### 演習2-1 デバッガの起動〜プログラム実行〜終了
1. デバッグ用にコンパイルする。
```
gcc -g -O0 basic.c -o basic
```
2. デバッガを起動する
+ gdb
```
sudo gdb basic
```
+ lldb
```
lldb basic
```
3. プログラムを実行する。
+ gdb
```
(gdb) run
```
+ lldb
```
(lldb) run
```
4. デバッガを終了する。
+ gdb
```
(gdb) quit
```
+ lldb
```
(lldb) quit
```

### 演習2-2 行数でブレークポイントを設定する
1. デバッガを起動する
+ gdb
```
sudo gdb basic
```
+ lldb
```
lldb basic
```
2. 行番号をチェックする。
+ gdb
```
(gdb) list basic.c:1,25
```
+ lldb
```
(lldb) list basic:1
```
※lldbでは、開始行数しか指定出来なかった・・・
3. 行にbreakpointをセットする。
+ gdb
```
(gdb) break basic.c:10
(gdb) b basic.c:12
```
+ lldb
```
(lldb) breakpoint set --file basic.c --line 10 
(lldb) b basic.c:12 
```
4. breakpointをチェックする
+ gdb
```
(gdb) info breakpoints
```

5. 次のbreakpointまで実行する。
```
(gdb) continue 
```

6. breakpointを削除する。
```
(gdb) delete 1
```
7. breakpointを全部削除する。
```
(gdb) clear
```

### 演習2-3 関数でブレークポイントを設定する
1. デバッガを起動する。

2. 関数名でbreakpointを設定する。

### 演習2-4 変数の中身を見る

### 演習2-5 変数の変更を監視する

## 演習3 gdbを使った他人のコードのデバッグ



# 5. gdbとcoredump


